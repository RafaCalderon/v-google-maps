"use strict";Object.defineProperty(exports,Symbol.toStringTag,{value:"Module"});const a=require("vue");function ue(s,e,t,r){function o(i){return i instanceof t?i:new t(function(n){n(i)})}return new(t||(t=Promise))(function(i,n){function d(f){try{u(r.next(f))}catch(p){n(p)}}function l(f){try{u(r.throw(f))}catch(p){n(p)}}function u(f){f.done?i(f.value):o(f.value).then(d,l)}u((r=r.apply(s,[])).next())})}function ce(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var he=function s(e,t){if(e===t)return!0;if(e&&t&&typeof e=="object"&&typeof t=="object"){if(e.constructor!==t.constructor)return!1;var r,o,i;if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(o=r;o--!==0;)if(!s(e[o],t[o]))return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if(i=Object.keys(e),r=i.length,r!==Object.keys(t).length)return!1;for(o=r;o--!==0;)if(!Object.prototype.hasOwnProperty.call(t,i[o]))return!1;for(o=r;o--!==0;){var n=i[o];if(!s(e[n],t[n]))return!1}return!0}return e!==e&&t!==t},de=ce(he);const H="__googleMapsScriptId";var j;(function(s){s[s.INITIALIZED=0]="INITIALIZED",s[s.LOADING=1]="LOADING",s[s.SUCCESS=2]="SUCCESS",s[s.FAILURE=3]="FAILURE"})(j||(j={}));class P{constructor({apiKey:e,authReferrerPolicy:t,channel:r,client:o,id:i=H,language:n,libraries:d=[],mapIds:l,nonce:u,region:f,retries:p=3,url:c="https://maps.googleapis.com/maps/api/js",version:m}){if(this.callbacks=[],this.done=!1,this.loading=!1,this.errors=[],this.apiKey=e,this.authReferrerPolicy=t,this.channel=r,this.client=o,this.id=i||H,this.language=n,this.libraries=d,this.mapIds=l,this.nonce=u,this.region=f,this.retries=p,this.url=c,this.version=m,P.instance){if(!de(this.options,P.instance.options))throw new Error(`Loader must not be called again with different options. ${JSON.stringify(this.options)} !== ${JSON.stringify(P.instance.options)}`);return P.instance}P.instance=this}get options(){return{version:this.version,apiKey:this.apiKey,channel:this.channel,client:this.client,id:this.id,libraries:this.libraries,language:this.language,region:this.region,mapIds:this.mapIds,nonce:this.nonce,url:this.url,authReferrerPolicy:this.authReferrerPolicy}}get status(){return this.errors.length?j.FAILURE:this.done?j.SUCCESS:this.loading?j.LOADING:j.INITIALIZED}get failed(){return this.done&&!this.loading&&this.errors.length>=this.retries+1}createUrl(){let e=this.url;return e+="?callback=__googleMapsCallback&loading=async",this.apiKey&&(e+=`&key=${this.apiKey}`),this.channel&&(e+=`&channel=${this.channel}`),this.client&&(e+=`&client=${this.client}`),this.libraries.length>0&&(e+=`&libraries=${this.libraries.join(",")}`),this.language&&(e+=`&language=${this.language}`),this.region&&(e+=`&region=${this.region}`),this.version&&(e+=`&v=${this.version}`),this.mapIds&&(e+=`&map_ids=${this.mapIds.join(",")}`),this.authReferrerPolicy&&(e+=`&auth_referrer_policy=${this.authReferrerPolicy}`),e}deleteScript(){const e=document.getElementById(this.id);e&&e.remove()}load(){return this.loadPromise()}loadPromise(){return new Promise((e,t)=>{this.loadCallback(r=>{r?t(r.error):e(window.google)})})}importLibrary(e){return this.execute(),google.maps.importLibrary(e)}loadCallback(e){this.callbacks.push(e),this.execute()}setScript(){var e,t;if(document.getElementById(this.id)){this.callback();return}const r={key:this.apiKey,channel:this.channel,client:this.client,libraries:this.libraries.length&&this.libraries,v:this.version,mapIds:this.mapIds,language:this.language,region:this.region,authReferrerPolicy:this.authReferrerPolicy};Object.keys(r).forEach(i=>!r[i]&&delete r[i]),!((t=(e=window==null?void 0:window.google)===null||e===void 0?void 0:e.maps)===null||t===void 0)&&t.importLibrary||(i=>{let n,d,l,u="The Google Maps JavaScript API",f="google",p="importLibrary",c="__ib__",m=document,h=window;h=h[f]||(h[f]={});const y=h.maps||(h.maps={}),v=new Set,k=new URLSearchParams,M=()=>n||(n=new Promise((g,w)=>ue(this,void 0,void 0,function*(){var S;yield d=m.createElement("script"),d.id=this.id,k.set("libraries",[...v]+"");for(l in i)k.set(l.replace(/[A-Z]/g,Z=>"_"+Z[0].toLowerCase()),i[l]);k.set("callback",f+".maps."+c),d.src=this.url+"?"+k,y[c]=g,d.onerror=()=>n=w(Error(u+" could not load.")),d.nonce=this.nonce||((S=m.querySelector("script[nonce]"))===null||S===void 0?void 0:S.nonce)||"",m.head.append(d)})));y[p]?console.warn(u+" only loads once. Ignoring:",i):y[p]=(g,...w)=>v.add(g)&&M().then(()=>y[p](g,...w))})(r);const o=this.libraries.map(i=>this.importLibrary(i));o.length||o.push(this.importLibrary("core")),Promise.all(o).then(()=>this.callback(),i=>{const n=new ErrorEvent("error",{error:i});this.loadErrorCallback(n)})}reset(){this.deleteScript(),this.done=!1,this.loading=!1,this.errors=[],this.onerrorEvent=null}resetIfRetryingFailed(){this.failed&&this.reset()}loadErrorCallback(e){if(this.errors.push(e),this.errors.length<=this.retries){const t=this.errors.length*Math.pow(2,this.errors.length);console.error(`Failed to load Google Maps script, retrying in ${t} ms.`),setTimeout(()=>{this.deleteScript(),this.setScript()},t)}else this.onerrorEvent=e,this.callback()}callback(){this.done=!0,this.loading=!1,this.callbacks.forEach(e=>{e(this.onerrorEvent)}),this.callbacks=[]}execute(){if(this.resetIfRetryingFailed(),!this.loading)if(this.done)this.callback();else{if(window.google&&window.google.maps&&window.google.maps.version){console.warn("Google Maps already loaded outside @googlemaps/js-api-loader. This may result in undesirable behavior as options and script parameters may not match."),this.callback();return}this.loading=!0,this.setScript()}}}const x=a.ref(null),X=a.ref(null),ee=a.ref(null),te=a.ref(null),re=a.ref(null);async function pe(s,e=[]){x.value||(x.value=new P({apiKey:s,libraries:e}),X.value=await x.value.importLibrary("core"),ee.value=await x.value.importLibrary("maps"),te.value=await x.value.importLibrary("marker"),re.value=await x.value.importLibrary("visualization"))}function b(){return{maps:ee,init:pe,core:X,loader:x,markers:te,visualization:re}}function fe(s){return s&&s.__esModule&&Object.prototype.hasOwnProperty.call(s,"default")?s.default:s}var me=function s(e,t){if(e===t)return!0;if(e&&t&&typeof e=="object"&&typeof t=="object"){if(e.constructor!==t.constructor)return!1;var r,o,i;if(Array.isArray(e)){if(r=e.length,r!=t.length)return!1;for(o=r;o--!==0;)if(!s(e[o],t[o]))return!1;return!0}if(e.constructor===RegExp)return e.source===t.source&&e.flags===t.flags;if(e.valueOf!==Object.prototype.valueOf)return e.valueOf()===t.valueOf();if(e.toString!==Object.prototype.toString)return e.toString()===t.toString();if(i=Object.keys(e),r=i.length,r!==Object.keys(t).length)return!1;for(o=r;o--!==0;)if(!Object.prototype.hasOwnProperty.call(t,i[o]))return!1;for(o=r;o--!==0;){var n=i[o];if(!s(e[n],t[n]))return!1}return!0}return e!==e&&t!==t};const _=fe(me),O=Symbol("map"),ne=Symbol("marker"),oe=Symbol("marker-clusterer"),ge=a.defineComponent({__name:"VGoogleMap",props:a.mergeModels({class:{},options:{}},{zoom:{default:null},zoomModifiers:{},center:{default:null},centerModifiers:{}}),emits:a.mergeModels(["ready","click"],["update:zoom","update:center"]),setup(s,{expose:e,emit:t}){const r=s,o=t,i=a.useModel(s,"zoom"),n=a.useModel(s,"center"),{maps:d}=b(),l=a.ref(!1),u=a.ref(null);let f=null,p=null,c=null;const m=a.ref(null);a.onMounted(async()=>{var v,k;!d.value||!m.value||(u.value=a.markRaw(new d.value.Map(m.value,{...r.options,zoom:i.value??((v=r.options)==null?void 0:v.zoom),center:n.value??((k=r.options)==null?void 0:k.center)})),l.value=!0,await a.nextTick(),h(),o("ready"))});function h(){u.value&&(f=u.value.addListener("click",v=>{o("click",v)}),p=u.value.addListener("dragend",()=>{var v,k;n.value=((k=(v=u.value)==null?void 0:v.getCenter())==null?void 0:k.toJSON())??null}),c=u.value.addListener("zoom_changed",()=>{var v;i.value=((v=u.value)==null?void 0:v.getZoom())??0}))}function y(){f==null||f.remove(),p==null||p.remove(),c==null||c.remove()}return a.watch(()=>r.options,(v,k)=>{!u.value||_(v,k)||u.value.setOptions(r.options)},{deep:!0}),a.watch(n,(v,k)=>{_(v,k)||!u.value||!v||u.value.setCenter({...v})}),a.watch(i,(v,k)=>{_(v,k)||!u.value||!v||u.value.setZoom(v)}),e({map:u}),a.provide(O,u),a.onBeforeUnmount(()=>{y(),u.value=null}),(v,k)=>(a.openBlock(),a.createElementBlock(a.Fragment,null,[a.createElementVNode("div",{ref_key:"mapRef",ref:m,class:a.normalizeClass(r.class)},null,2),l.value?a.renderSlot(v.$slots,"default",{key:0}):a.createCommentVNode("",!0)],64))}}),ve=a.defineComponent({name:"VGoogleCircle",props:{options:{required:!0,type:Object},center:{default:null,type:Object},radius:{default:null,type:Number}},emits:["click","update:center","update:radius"],setup(s,{emit:e,expose:t,slots:r}){const{maps:o}=b(),i=a.inject(O,a.ref(null)),n=a.ref(null);let d=null,l=null,u=null;a.onMounted(()=>{var h,y;i.value&&o.value&&(n.value=a.markRaw(new o.value.Circle({...s.options,map:i.value,center:f.value??((h=s.options)==null?void 0:h.center),radius:p.value??((y=s.options)==null?void 0:y.radius)})),c())});const f=a.computed({get(){return s.center},set(h){e("update:center",h)}}),p=a.computed({get(){return s.radius},set(h){e("update:radius",h)}});function c(){n.value&&(d=n.value.addListener("click",h=>{e("click",h)}),l=n.value.addListener("radius_changed",()=>{var h;p.value=((h=n.value)==null?void 0:h.getRadius())??null}),u=n.value.addListener("center_changed",()=>{var y,v;const h=(v=(y=n.value)==null?void 0:y.getCenter())==null?void 0:v.toJSON();h&&(f.value={...h})}))}function m(){d==null||d.remove(),l==null||l.remove(),u==null||u.remove()}return a.watch(()=>s.options,(h,y)=>{!n.value||_(h,y)||n.value.setOptions(s.options)},{deep:!0}),a.watch(f,(h,y)=>{!n.value||!h||_(h,y)||n.value.setCenter({...h})}),a.watch(p,(h,y)=>{!n.value||!h||_(h,y)||n.value.setRadius(h)}),t({circle:n}),a.onBeforeUnmount(()=>{m(),n.value&&(n.value.setMap(null),n.value=null)}),()=>{var h;return(h=r.default)==null?void 0:h.call(r)}}}),ye=a.defineComponent({name:"VGoogleHeatmap",props:{options:{required:!0,type:Object}},setup(s,{expose:e,slots:t}){const{visualization:r}=b(),o=a.inject(O,a.ref(null)),i=a.ref(null);return a.onMounted(()=>{o.value&&r.value&&(i.value=a.markRaw(new r.value.HeatmapLayer({map:o.value,...s.options})))}),a.watch(()=>s.options,(n,d)=>{!i.value||_(n,d)||i.value.setOptions(s.options)},{deep:!0}),e({heatmap:i}),a.onBeforeUnmount(()=>{i.value&&(i.value.setMap(null),i.value=null)}),()=>{var n;return(n=t.default)==null?void 0:n.call(t)}}}),ke=a.defineComponent({name:"VGooglePolygon",props:{options:{required:!0,type:Object},modelValue:{default:null,type:Object}},emits:["click","mouseover","mouseout","update:model-value"],setup(s,{emit:e,expose:t,slots:r}){const{maps:o}=b(),i=a.inject(O,a.ref(null)),n=a.ref(null);let d=null,l=null,u=null,f=null;a.onMounted(()=>{var h;i.value&&o.value&&(n.value=a.markRaw(new o.value.Polygon({...s.options,map:i.value,paths:p.value?[...p.value]:(h=s.options)==null?void 0:h.paths})),c())});const p=a.computed({get(){return s.modelValue},set(h){e("update:model-value",h)}});function c(){n.value&&(d=n.value.addListener("click",h=>{e("click",h)}),u=n.value.addListener("mouseout",h=>{e("mouseout",h)}),f=n.value.addListener("mouseover",h=>{e("mouseover",h)}),l=n.value.addListener("mouseup",()=>{var y,v,k;const h=(k=(v=(y=n.value)==null?void 0:y.getPath())==null?void 0:v.getArray())==null?void 0:k.map(M=>M.toJSON());h&&(p.value=[...h])}))}function m(){d==null||d.remove(),l==null||l.remove(),u==null||u.remove(),f==null||f.remove()}return a.watch(()=>s.options,(h,y)=>{!n.value||_(h,y)||n.value.setOptions(s.options)},{deep:!0}),a.watch(p,(h,y)=>{!n.value||!h||_(h,y)||n.value.setPath(h)}),t({polygon:n}),a.onBeforeUnmount(()=>{m(),n.value&&(n.value.setMap(null),n.value=null)}),()=>{var h;return(h=r.default)==null?void 0:h.call(r)}}}),Me={key:0,style:{display:"none"}},se=a.defineComponent({__name:"VGoogleInfoWindow",props:a.mergeModels({options:{default:null}},{modelValue:{type:Boolean,default:!1,required:!1},modelModifiers:{}}),emits:["update:modelValue"],setup(s,{expose:e}){const t=s,r=a.useModel(s,"modelValue"),o=a.useSlots(),{maps:i}=b(),n=a.inject(O,a.ref(null)),d=a.inject(ne,a.ref(null)),l=a.ref(!1),u=a.ref(),f=a.ref(null);let p=null,c=null;a.onMounted(async()=>{var M;i.value&&(f.value=a.markRaw(new i.value.InfoWindow({...t.options,content:m.value&&!h.value?u.value:(M=t.options)==null?void 0:M.content})),await a.nextTick(),y(),r.value&&k())});const m=a.computed(()=>{var M,g;return((g=(M=o.default)==null?void 0:M.call(o))==null?void 0:g[0])??null}),h=a.computed(()=>{var M;return((M=m.value)==null?void 0:M.type)===Comment});function y(){!d.value||!f.value||(c=d.value.addListener("click",k),p=f.value.addListener("closeclick",k))}function v(){c&&c.remove(),p&&p.remove()}function k(){!f.value||!n.value||(l.value=!l.value,l.value?f.value.open({map:n.value,anchor:d.value}):f.value.close(),r.value=l.value)}return a.watch(()=>t.options,(M,g)=>{!f.value||_(M,g)||f.value.setOptions(t.options)},{deep:!0}),a.watch(r,M=>{M===null||M===l.value||k()}),e({infoWindow:f}),a.onBeforeUnmount(()=>{v(),f.value&&(f.value.close(),f.value=null)}),(M,g)=>m.value&&!h.value?(a.openBlock(),a.createElementBlock("div",Me,[a.createElementVNode("div",{ref_key:"contentRef",ref:u},[a.renderSlot(M.$slots,"default")],512)])):a.createCommentVNode("",!0)}}),we={key:0,style:{display:"none"}},_e=a.defineComponent({__name:"VGoogleMarker",props:a.mergeModels({options:{default:void 0}},{modelValue:{default:null,required:!1},modelModifiers:{}}),emits:a.mergeModels(["click"],["update:modelValue"]),setup(s,{expose:e,emit:t}){const r=s,o=t,i=a.useModel(s,"modelValue"),n=a.useSlots(),{markers:d}=b(),l=a.inject(O,a.ref(null)),u=a.inject(oe,a.ref(null)),f=a.ref();let p=null,c=null;const m=a.ref(null);a.onMounted(async()=>{var g,w;d.value&&(m.value=a.markRaw(new d.value.AdvancedMarkerElement({...r.options,position:i.value??((g=r.options)==null?void 0:g.position),map:u.value===null?l.value:null,content:h.value&&!y.value&&!v.value?f.value:(w=r.options)==null?void 0:w.content})),await a.nextTick(),u.value&&u.value.addMarker(m.value),k())});const h=a.computed(()=>{var g,w;return((w=(g=n.default)==null?void 0:g.call(n))==null?void 0:w[0])??null}),y=a.computed(()=>{var g;return((g=h.value)==null?void 0:g.type)===Comment}),v=a.computed(()=>{var g;return((g=h.value)==null?void 0:g.type)===se});function k(){m.value&&(c=m.value.addListener("dragend",g=>{var w;i.value=((w=g.latLng)==null?void 0:w.toJSON())??null}),p=m.value.addListener("click",g=>{o("click",g)}))}function M(){p==null||p.remove(),c==null||c.remove()}return a.watch(()=>r.options,(g,w)=>{!m.value||_(g,w)||(g!=null&&g.title&&(m.value.title=g.title),g!=null&&g.zIndex&&(m.value.zIndex=g.zIndex),g!=null&&g.content&&(m.value.content=g.content),g!=null&&g.position&&(m.value.position=g.position),g!=null&&g.gmpDraggable&&(m.value.gmpDraggable=g.gmpDraggable))},{deep:!0}),a.watch(i,(g,w)=>{!m.value||_(g,w)||(m.value.position=g)}),e({marker:m}),a.provide(ne,m),a.onBeforeUnmount(()=>{M(),m.value&&(u.value&&u.value.removeMarker(m.value),m.value.map=null,m.value=null)}),(g,w)=>h.value&&!y.value?(a.openBlock(),a.createElementBlock("div",we,[a.createElementVNode("div",{ref_key:"contentRef",ref:f},[a.renderSlot(g.$slots,"default")],512)])):a.createCommentVNode("",!0)}}),Ee=a.defineComponent({name:"VGooglePolyline",props:{options:{required:!0,type:Object},modelValue:{default:null,type:Object}},emits:["click","update:model-value"],setup(s,{emit:e,expose:t,slots:r}){const{maps:o}=b(),i=a.inject(O,a.ref(null)),n=a.ref(null);let d=null,l=null;a.onMounted(()=>{var c;i.value&&o.value&&(n.value=a.markRaw(new o.value.Polyline({...s.options,map:i.value,path:u.value?[...u.value]:(c=s.options)==null?void 0:c.path})),f())});const u=a.computed({get(){return s.modelValue},set(c){e("update:model-value",c)}});function f(){n.value&&(d=n.value.addListener("click",c=>{e("click",c)}),l=n.value.addListener("mouseup",()=>{var m,h,y;const c=(y=(h=(m=n.value)==null?void 0:m.getPath())==null?void 0:h.getArray())==null?void 0:y.map(v=>v.toJSON());c&&(u.value=[...c])}))}function p(){d==null||d.remove(),l==null||l.remove()}return a.watch(()=>s.options,(c,m)=>{!n.value||_(c,m)||n.value.setOptions(s.options)},{deep:!0}),a.watch(u,(c,m)=>{!n.value||!c||_(c,m)||n.value.setPath(c)}),t({polyline:n}),a.onBeforeUnmount(()=>{p(),n.value&&(n.value.setMap(null),n.value=null)}),()=>{var c;return(c=r.default)==null?void 0:c.call(r)}}}),be=a.defineComponent({name:"VGoogleRectangle",props:{options:{required:!0,type:Object},modelValue:{default:null,type:Object}},emits:["click","update:model-value"],setup(s,{emit:e,expose:t,slots:r}){const{maps:o}=b(),i=a.inject(O,a.ref(null)),n=a.ref(null);let d=null,l=null;a.onMounted(()=>{var c;i.value&&o.value&&(n.value=a.markRaw(new o.value.Rectangle({...s.options,map:i.value,bounds:u.value??((c=s.options)==null?void 0:c.bounds)})),f())});const u=a.computed({get(){return s.modelValue},set(c){e("update:model-value",c)}});function f(){n.value&&(d=n.value.addListener("click",c=>{e("click",c)}),l=n.value.addListener("bounds_changed",()=>{var m,h;const c=(h=(m=n.value)==null?void 0:m.getBounds())==null?void 0:h.toJSON();c&&(u.value={...c})}))}function p(){d==null||d.remove(),l==null||l.remove()}return a.watch(()=>s.options,(c,m)=>{!n.value||_(c,m)||n.value.setOptions(s.options)},{deep:!0}),a.watch(u,(c,m)=>{!n.value||!c||_(c,m)||n.value.setBounds(c)}),t({rectangle:n}),a.onBeforeUnmount(()=>{p(),n.value&&(n.value.setMap(null),n.value=null)}),()=>{var c;return(c=r.default)==null?void 0:c.call(r)}}}),W=[Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array],B=1,R=8;class q{static from(e){if(!(e instanceof ArrayBuffer))throw new Error("Data must be an instance of ArrayBuffer.");const[t,r]=new Uint8Array(e,0,2);if(t!==219)throw new Error("Data does not appear to be in a KDBush format.");const o=r>>4;if(o!==B)throw new Error(`Got v${o} data when expected v${B}.`);const i=W[r&15];if(!i)throw new Error("Unrecognized array type.");const[n]=new Uint16Array(e,2,1),[d]=new Uint32Array(e,4,1);return new q(d,n,i,e)}constructor(e,t=64,r=Float64Array,o){if(isNaN(e)||e<0)throw new Error(`Unpexpected numItems value: ${e}.`);this.numItems=+e,this.nodeSize=Math.min(Math.max(+t,2),65535),this.ArrayType=r,this.IndexArrayType=e<65536?Uint16Array:Uint32Array;const i=W.indexOf(this.ArrayType),n=e*2*this.ArrayType.BYTES_PER_ELEMENT,d=e*this.IndexArrayType.BYTES_PER_ELEMENT,l=(8-d%8)%8;if(i<0)throw new Error(`Unexpected typed array class: ${r}.`);o&&o instanceof ArrayBuffer?(this.data=o,this.ids=new this.IndexArrayType(this.data,R,e),this.coords=new this.ArrayType(this.data,R+d+l,e*2),this._pos=e*2,this._finished=!0):(this.data=new ArrayBuffer(R+n+d+l),this.ids=new this.IndexArrayType(this.data,R,e),this.coords=new this.ArrayType(this.data,R+d+l,e*2),this._pos=0,this._finished=!1,new Uint8Array(this.data,0,2).set([219,(B<<4)+i]),new Uint16Array(this.data,2,1)[0]=t,new Uint32Array(this.data,4,1)[0]=e)}add(e,t){const r=this._pos>>1;return this.ids[r]=r,this.coords[this._pos++]=e,this.coords[this._pos++]=t,r}finish(){const e=this._pos>>1;if(e!==this.numItems)throw new Error(`Added ${e} items when expected ${this.numItems}.`);return D(this.ids,this.coords,this.nodeSize,0,this.numItems-1,0),this._finished=!0,this}range(e,t,r,o){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:i,coords:n,nodeSize:d}=this,l=[0,i.length-1,0],u=[];for(;l.length;){const f=l.pop()||0,p=l.pop()||0,c=l.pop()||0;if(p-c<=d){for(let v=c;v<=p;v++){const k=n[2*v],M=n[2*v+1];k>=e&&k<=r&&M>=t&&M<=o&&u.push(i[v])}continue}const m=c+p>>1,h=n[2*m],y=n[2*m+1];h>=e&&h<=r&&y>=t&&y<=o&&u.push(i[m]),(f===0?e<=h:t<=y)&&(l.push(c),l.push(m-1),l.push(1-f)),(f===0?r>=h:o>=y)&&(l.push(m+1),l.push(p),l.push(1-f))}return u}within(e,t,r){if(!this._finished)throw new Error("Data not yet indexed - call index.finish().");const{ids:o,coords:i,nodeSize:n}=this,d=[0,o.length-1,0],l=[],u=r*r;for(;d.length;){const f=d.pop()||0,p=d.pop()||0,c=d.pop()||0;if(p-c<=n){for(let v=c;v<=p;v++)V(i[2*v],i[2*v+1],e,t)<=u&&l.push(o[v]);continue}const m=c+p>>1,h=i[2*m],y=i[2*m+1];V(h,y,e,t)<=u&&l.push(o[m]),(f===0?e-r<=h:t-r<=y)&&(d.push(c),d.push(m-1),d.push(1-f)),(f===0?e+r>=h:t+r>=y)&&(d.push(m+1),d.push(p),d.push(1-f))}return l}}function D(s,e,t,r,o,i){if(o-r<=t)return;const n=r+o>>1;ie(s,e,n,r,o,i),D(s,e,t,r,n-1,1-i),D(s,e,t,n+1,o,1-i)}function ie(s,e,t,r,o,i){for(;o>r;){if(o-r>600){const u=o-r+1,f=t-r+1,p=Math.log(u),c=.5*Math.exp(2*p/3),m=.5*Math.sqrt(p*c*(u-c)/u)*(f-u/2<0?-1:1),h=Math.max(r,Math.floor(t-f*c/u+m)),y=Math.min(o,Math.floor(t+(u-f)*c/u+m));ie(s,e,t,h,y,i)}const n=e[2*t+i];let d=r,l=o;for(T(s,e,r,t),e[2*o+i]>n&&T(s,e,r,o);d<l;){for(T(s,e,d,l),d++,l--;e[2*d+i]<n;)d++;for(;e[2*l+i]>n;)l--}e[2*r+i]===n?T(s,e,r,l):(l++,T(s,e,l,o)),l<=t&&(r=l+1),t<=l&&(o=l-1)}}function T(s,e,t,r){F(s,t,r),F(e,2*t,2*r),F(e,2*t+1,2*r+1)}function F(s,e,t){const r=s[e];s[e]=s[t],s[t]=r}function V(s,e,t,r){const o=s-t,i=e-r;return o*o+i*i}const Oe={minZoom:0,maxZoom:16,minPoints:2,radius:40,extent:512,nodeSize:64,log:!1,generateId:!1,reduce:null,map:s=>s},Y=Math.fround||(s=>e=>(s[0]=+e,s[0]))(new Float32Array(1)),L=2,A=3,$=4,C=5,ae=6;class Ce{constructor(e){this.options=Object.assign(Object.create(Oe),e),this.trees=new Array(this.options.maxZoom+1),this.stride=this.options.reduce?7:6,this.clusterProps=[]}load(e){const{log:t,minZoom:r,maxZoom:o}=this.options;t&&console.time("total time");const i=`prepare ${e.length} points`;t&&console.time(i),this.points=e;const n=[];for(let l=0;l<e.length;l++){const u=e[l];if(!u.geometry)continue;const[f,p]=u.geometry.coordinates,c=Y(N(f)),m=Y(U(p));n.push(c,m,1/0,l,-1,1),this.options.reduce&&n.push(0)}let d=this.trees[o+1]=this._createTree(n);t&&console.timeEnd(i);for(let l=o;l>=r;l--){const u=+Date.now();d=this.trees[l]=this._createTree(this._cluster(d,l)),t&&console.log("z%d: %d clusters in %dms",l,d.numItems,+Date.now()-u)}return t&&console.timeEnd("total time"),this}getClusters(e,t){let r=((e[0]+180)%360+360)%360-180;const o=Math.max(-90,Math.min(90,e[1]));let i=e[2]===180?180:((e[2]+180)%360+360)%360-180;const n=Math.max(-90,Math.min(90,e[3]));if(e[2]-e[0]>=360)r=-180,i=180;else if(r>i){const p=this.getClusters([r,o,180,n],t),c=this.getClusters([-180,o,i,n],t);return p.concat(c)}const d=this.trees[this._limitZoom(t)],l=d.range(N(r),U(n),N(i),U(o)),u=d.data,f=[];for(const p of l){const c=this.stride*p;f.push(u[c+C]>1?Q(u,c,this.clusterProps):this.points[u[c+A]])}return f}getChildren(e){const t=this._getOriginId(e),r=this._getOriginZoom(e),o="No cluster with the specified id.",i=this.trees[r];if(!i)throw new Error(o);const n=i.data;if(t*this.stride>=n.length)throw new Error(o);const d=this.options.radius/(this.options.extent*Math.pow(2,r-1)),l=n[t*this.stride],u=n[t*this.stride+1],f=i.within(l,u,d),p=[];for(const c of f){const m=c*this.stride;n[m+$]===e&&p.push(n[m+C]>1?Q(n,m,this.clusterProps):this.points[n[m+A]])}if(p.length===0)throw new Error(o);return p}getLeaves(e,t,r){t=t||10,r=r||0;const o=[];return this._appendLeaves(o,e,t,r,0),o}getTile(e,t,r){const o=this.trees[this._limitZoom(e)],i=Math.pow(2,e),{extent:n,radius:d}=this.options,l=d/n,u=(r-l)/i,f=(r+1+l)/i,p={features:[]};return this._addTileFeatures(o.range((t-l)/i,u,(t+1+l)/i,f),o.data,t,r,i,p),t===0&&this._addTileFeatures(o.range(1-l/i,u,1,f),o.data,i,r,i,p),t===i-1&&this._addTileFeatures(o.range(0,u,l/i,f),o.data,-1,r,i,p),p.features.length?p:null}getClusterExpansionZoom(e){let t=this._getOriginZoom(e)-1;for(;t<=this.options.maxZoom;){const r=this.getChildren(e);if(t++,r.length!==1)break;e=r[0].properties.cluster_id}return t}_appendLeaves(e,t,r,o,i){const n=this.getChildren(t);for(const d of n){const l=d.properties;if(l&&l.cluster?i+l.point_count<=o?i+=l.point_count:i=this._appendLeaves(e,l.cluster_id,r,o,i):i<o?i++:e.push(d),e.length===r)break}return i}_createTree(e){const t=new q(e.length/this.stride|0,this.options.nodeSize,Float32Array);for(let r=0;r<e.length;r+=this.stride)t.add(e[r],e[r+1]);return t.finish(),t.data=e,t}_addTileFeatures(e,t,r,o,i,n){for(const d of e){const l=d*this.stride,u=t[l+C]>1;let f,p,c;if(u)f=le(t,l,this.clusterProps),p=t[l],c=t[l+1];else{const y=this.points[t[l+A]];f=y.properties;const[v,k]=y.geometry.coordinates;p=N(v),c=U(k)}const m={type:1,geometry:[[Math.round(this.options.extent*(p*i-r)),Math.round(this.options.extent*(c*i-o))]],tags:f};let h;u||this.options.generateId?h=t[l+A]:h=this.points[t[l+A]].id,h!==void 0&&(m.id=h),n.features.push(m)}}_limitZoom(e){return Math.max(this.options.minZoom,Math.min(Math.floor(+e),this.options.maxZoom+1))}_cluster(e,t){const{radius:r,extent:o,reduce:i,minPoints:n}=this.options,d=r/(o*Math.pow(2,t)),l=e.data,u=[],f=this.stride;for(let p=0;p<l.length;p+=f){if(l[p+L]<=t)continue;l[p+L]=t;const c=l[p],m=l[p+1],h=e.within(l[p],l[p+1],d),y=l[p+C];let v=y;for(const k of h){const M=k*f;l[M+L]>t&&(v+=l[M+C])}if(v>y&&v>=n){let k=c*y,M=m*y,g,w=-1;const S=((p/f|0)<<5)+(t+1)+this.points.length;for(const Z of h){const I=Z*f;if(l[I+L]<=t)continue;l[I+L]=t;const K=l[I+C];k+=l[I]*K,M+=l[I+1]*K,l[I+$]=S,i&&(g||(g=this._map(l,p,!0),w=this.clusterProps.length,this.clusterProps.push(g)),i(g,this._map(l,I)))}l[p+$]=S,u.push(k/v,M/v,1/0,S,-1,v),i&&u.push(w)}else{for(let k=0;k<f;k++)u.push(l[p+k]);if(v>1)for(const k of h){const M=k*f;if(!(l[M+L]<=t)){l[M+L]=t;for(let g=0;g<f;g++)u.push(l[M+g])}}}}return u}_getOriginId(e){return e-this.points.length>>5}_getOriginZoom(e){return(e-this.points.length)%32}_map(e,t,r){if(e[t+C]>1){const n=this.clusterProps[e[t+ae]];return r?Object.assign({},n):n}const o=this.points[e[t+A]].properties,i=this.options.map(o);return r&&i===o?Object.assign({},i):i}}function Q(s,e,t){return{type:"Feature",id:s[e+A],properties:le(s,e,t),geometry:{type:"Point",coordinates:[Ae(s[e]),Se(s[e+1])]}}}function le(s,e,t){const r=s[e+C],o=r>=1e4?`${Math.round(r/1e3)}k`:r>=1e3?`${Math.round(r/100)/10}k`:r,i=s[e+ae],n=i===-1?{}:Object.assign({},t[i]);return Object.assign(n,{cluster:!0,cluster_id:s[e+A],point_count:r,point_count_abbreviated:o})}function N(s){return s/360+.5}function U(s){const e=Math.sin(s*Math.PI/180),t=.5-.25*Math.log((1+e)/(1-e))/Math.PI;return t<0?0:t>1?1:t}function Ae(s){return(s-.5)*360}function Se(s){const e=(180-s*360)*Math.PI/180;return 360*Math.atan(Math.exp(e))/Math.PI-90}/*! *****************************************************************************
Copyright (c) Microsoft Corporation.

Permission to use, copy, modify, and/or distribute this software for any
purpose with or without fee is hereby granted.

THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH
REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY
AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,
INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM
LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR
OTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR
PERFORMANCE OF THIS SOFTWARE.
***************************************************************************** */function Ie(s,e){var t={};for(var r in s)Object.prototype.hasOwnProperty.call(s,r)&&e.indexOf(r)<0&&(t[r]=s[r]);if(s!=null&&typeof Object.getOwnPropertySymbols=="function")for(var o=0,r=Object.getOwnPropertySymbols(s);o<r.length;o++)e.indexOf(r[o])<0&&Object.prototype.propertyIsEnumerable.call(s,r[o])&&(t[r[o]]=s[r[o]]);return t}class E{static isAdvancedMarkerAvailable(e){return google.maps.marker&&e.getMapCapabilities().isAdvancedMarkersAvailable===!0}static isAdvancedMarker(e){return google.maps.marker&&e instanceof google.maps.marker.AdvancedMarkerElement}static setMap(e,t){this.isAdvancedMarker(e)?e.map=t:e.setMap(t)}static getPosition(e){if(this.isAdvancedMarker(e)){if(e.position){if(e.position instanceof google.maps.LatLng)return e.position;if(e.position.lat&&e.position.lng)return new google.maps.LatLng(e.position.lat,e.position.lng)}return new google.maps.LatLng(null)}return e.getPosition()}static getVisible(e){return this.isAdvancedMarker(e)?!0:e.getVisible()}}class z{constructor({markers:e,position:t}){this.markers=e,t&&(t instanceof google.maps.LatLng?this._position=t:this._position=new google.maps.LatLng(t))}get bounds(){if(this.markers.length===0&&!this._position)return;const e=new google.maps.LatLngBounds(this._position,this._position);for(const t of this.markers)e.extend(E.getPosition(t));return e}get position(){return this._position||this.bounds.getCenter()}get count(){return this.markers.filter(e=>E.getVisible(e)).length}push(e){this.markers.push(e)}delete(){this.marker&&(E.setMap(this.marker,null),this.marker=void 0),this.markers.length=0}}class Le{constructor({maxZoom:e=16}){this.maxZoom=e}noop({markers:e}){return xe(e)}}const xe=s=>s.map(t=>new z({position:E.getPosition(t),markers:[t]}));class Pe extends Le{constructor(e){var{maxZoom:t,radius:r=60}=e,o=Ie(e,["maxZoom","radius"]);super({maxZoom:t}),this.state={zoom:-1},this.superCluster=new Ce(Object.assign({maxZoom:this.maxZoom,radius:r},o))}calculate(e){let t=!1;const r={zoom:e.map.getZoom()};if(!_(e.markers,this.markers)){t=!0,this.markers=[...e.markers];const o=this.markers.map(i=>{const n=E.getPosition(i);return{type:"Feature",geometry:{type:"Point",coordinates:[n.lng(),n.lat()]},properties:{marker:i}}});this.superCluster.load(o)}return t||(this.state.zoom<=this.maxZoom||r.zoom<=this.maxZoom)&&(t=!_(this.state,r)),this.state=r,t&&(this.clusters=this.cluster(e)),{clusters:this.clusters,changed:t}}cluster({map:e}){return this.superCluster.getClusters([-180,-90,180,90],Math.round(e.getZoom())).map(t=>this.transformCluster(t))}transformCluster({geometry:{coordinates:[e,t]},properties:r}){if(r.cluster)return new z({markers:this.superCluster.getLeaves(r.cluster_id,1/0).map(i=>i.properties.marker),position:{lat:t,lng:e}});const o=r.marker;return new z({markers:[o],position:E.getPosition(o)})}}class je{constructor(e,t){this.markers={sum:e.length};const r=t.map(i=>i.count),o=r.reduce((i,n)=>i+n,0);this.clusters={count:t.length,markers:{mean:o/t.length,sum:o,min:Math.min(...r),max:Math.max(...r)}}}}class Re{render({count:e,position:t},r,o){const n=`<svg fill="${e>Math.max(10,r.clusters.markers.mean)?"#ff0000":"#0000ff"}" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 240 240" width="50" height="50">
<circle cx="120" cy="120" opacity=".6" r="70" />
<circle cx="120" cy="120" opacity=".3" r="90" />
<circle cx="120" cy="120" opacity=".2" r="110" />
<text x="50%" y="50%" style="fill:#fff" text-anchor="middle" font-size="50" dominant-baseline="middle" font-family="roboto,arial,sans-serif">${e}</text>
</svg>`,d=`Cluster of ${e} markers`,l=Number(google.maps.Marker.MAX_ZINDEX)+e;if(E.isAdvancedMarkerAvailable(o)){const p=new DOMParser().parseFromString(n,"image/svg+xml").documentElement;p.setAttribute("transform","translate(0 25)");const c={map:o,position:t,zIndex:l,title:d,content:p};return new google.maps.marker.AdvancedMarkerElement(c)}const u={position:t,zIndex:l,title:d,icon:{url:`data:image/svg+xml;base64,${btoa(n)}`,anchor:new google.maps.Point(25,25)}};return new google.maps.Marker(u)}}function Te(s,e){for(let t in e.prototype)s.prototype[t]=e.prototype[t]}class J{constructor(){Te(J,google.maps.OverlayView)}}var G;(function(s){s.CLUSTERING_BEGIN="clusteringbegin",s.CLUSTERING_END="clusteringend",s.CLUSTER_CLICK="click"})(G||(G={}));const Ge=(s,e,t)=>{t.fitBounds(e.bounds)};class Ne extends J{constructor({map:e,markers:t=[],algorithmOptions:r={},algorithm:o=new Pe(r),renderer:i=new Re,onClusterClick:n=Ge}){super(),this.markers=[...t],this.clusters=[],this.algorithm=o,this.renderer=i,this.onClusterClick=n,e&&this.setMap(e)}addMarker(e,t){this.markers.includes(e)||(this.markers.push(e),t||this.render())}addMarkers(e,t){e.forEach(r=>{this.addMarker(r,!0)}),t||this.render()}removeMarker(e,t){const r=this.markers.indexOf(e);return r===-1?!1:(E.setMap(e,null),this.markers.splice(r,1),t||this.render(),!0)}removeMarkers(e,t){let r=!1;return e.forEach(o=>{r=this.removeMarker(o,!0)||r}),r&&!t&&this.render(),r}clearMarkers(e){this.markers.length=0,e||this.render()}render(){const e=this.getMap();if(e instanceof google.maps.Map&&e.getProjection()){google.maps.event.trigger(this,G.CLUSTERING_BEGIN,this);const{clusters:t,changed:r}=this.algorithm.calculate({markers:this.markers,map:e,mapCanvasProjection:this.getProjection()});if(r||r==null){const o=new Set;for(const n of t)n.markers.length==1&&o.add(n.markers[0]);const i=[];for(const n of this.clusters)n.marker!=null&&(n.markers.length==1?o.has(n.marker)||E.setMap(n.marker,null):i.push(n.marker));this.clusters=t,this.renderClusters(),requestAnimationFrame(()=>i.forEach(n=>E.setMap(n,null)))}google.maps.event.trigger(this,G.CLUSTERING_END,this)}}onAdd(){this.idleListener=this.getMap().addListener("idle",this.render.bind(this)),this.render()}onRemove(){google.maps.event.removeListener(this.idleListener),this.reset()}reset(){this.markers.forEach(e=>E.setMap(e,null)),this.clusters.forEach(e=>e.delete()),this.clusters=[]}renderClusters(){const e=new je(this.markers,this.clusters),t=this.getMap();this.clusters.forEach(r=>{r.markers.length===1?r.marker=r.markers[0]:(r.marker=this.renderer.render(r,e,t),r.markers.forEach(o=>E.setMap(o,null)),this.onClusterClick&&r.marker.addListener("click",o=>{google.maps.event.trigger(this,G.CLUSTER_CLICK,r),this.onClusterClick(o,r,t)})),E.setMap(r.marker,t)})}}const Ue=a.defineComponent({name:"VGoogleMarkerClusterer",props:{options:{default:null,type:Object}},setup(s,{slots:e}){const t=a.inject(O,a.ref(null)),r=a.ref(null);return t.value&&(r.value=a.markRaw(new Ne({...s.options,map:t.value}))),a.provide(oe,r),a.onBeforeUnmount(()=>{r.value&&(r.value.setMap(null),r.value.clearMarkers(),r.value=null)}),()=>{var o;return(o=e.default)==null?void 0:o.call(e)}}});function Ze(s){s.component("VGoogleMap",ge),s.component("VGoogleCircle",ve),s.component("VGoogleMarker",_e),s.component("VGoogleHeatmap",ye),s.component("VGooglePolygon",ke),s.component("VGooglePolyline",Ee),s.component("VGoogleRectangle",be),s.component("VGoogleInfoWindow",se),s.component("VGoogleMarkerClusterer",Ue)}exports.useGoogleMapsLoader=b;exports.vGoogleMaps=Ze;
